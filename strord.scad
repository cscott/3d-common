// String utility: implement 'ord' to convert string to codepoint vector
// In a module by itself because it's long and repetitive.

// valid for codepoints <= U+007F
function ord(s) = len(s) != 1 ?
  [ for (i = [0:1:len(s)-1]) ord(s[i])[0] ] :
  // ugh.
  //s[0] == "\u0000" ? [0] : // XXX openSCAD turns \u0000 into \u0020 :(
  s[0] == "\u0001" ? [1] :
  s[0] == "\u0002" ? [2] :
  s[0] == "\u0003" ? [3] :
  s[0] == "\u0004" ? [4] :
  s[0] == "\u0005" ? [5] :
  s[0] == "\u0006" ? [6] :
  s[0] == "\u0007" ? [7] :
  s[0] == "\u0008" ? [8] :
  s[0] == "\u0009" ? [9] :
  s[0] == "\u000A" ? [10] :
  s[0] == "\u000B" ? [11] :
  s[0] == "\u000C" ? [12] :
  s[0] == "\u000D" ? [13] :
  s[0] == "\u000E" ? [14] :
  s[0] == "\u000F" ? [15] :
  s[0] == "\u0010" ? [16] :
  s[0] == "\u0011" ? [17] :
  s[0] == "\u0012" ? [18] :
  s[0] == "\u0013" ? [19] :
  s[0] == "\u0014" ? [20] :
  s[0] == "\u0015" ? [21] :
  s[0] == "\u0016" ? [22] :
  s[0] == "\u0017" ? [23] :
  s[0] == "\u0018" ? [24] :
  s[0] == "\u0019" ? [25] :
  s[0] == "\u001A" ? [26] :
  s[0] == "\u001B" ? [27] :
  s[0] == "\u001C" ? [28] :
  s[0] == "\u001D" ? [29] :
  s[0] == "\u001E" ? [30] :
  s[0] == "\u001F" ? [31] :
  s[0] == " " ? [32] :
  s[0] == "!" ? [33] :
  s[0] == "\"" ? [34] :
  s[0] == "#" ? [35] :
  s[0] == "$" ? [36] :
  s[0] == "%" ? [37] :
  s[0] == "&" ? [38] :
  s[0] == "'" ? [39] :
  s[0] == "(" ? [40] :
  s[0] == ")" ? [41] :
  s[0] == "*" ? [42] :
  s[0] == "+" ? [43] :
  s[0] == "," ? [44] :
  s[0] == "-" ? [45] :
  s[0] == "." ? [46] :
  s[0] == "/" ? [47] :
  s[0] == "0" ? [48] :
  s[0] == "1" ? [49] :
  s[0] == "2" ? [50] :
  s[0] == "3" ? [51] :
  s[0] == "4" ? [52] :
  s[0] == "5" ? [53] :
  s[0] == "6" ? [54] :
  s[0] == "7" ? [55] :
  s[0] == "8" ? [56] :
  s[0] == "9" ? [57] :
  s[0] == ":" ? [58] :
  s[0] == ";" ? [59] :
  s[0] == "<" ? [60] :
  s[0] == "=" ? [61] :
  s[0] == ">" ? [62] :
  s[0] == "?" ? [63] :
  s[0] == "@" ? [64] :
  s[0] == "A" ? [65] :
  s[0] == "B" ? [66] :
  s[0] == "C" ? [67] :
  s[0] == "D" ? [68] :
  s[0] == "E" ? [69] :
  s[0] == "F" ? [70] :
  s[0] == "G" ? [71] :
  s[0] == "H" ? [72] :
  s[0] == "I" ? [73] :
  s[0] == "J" ? [74] :
  s[0] == "K" ? [75] :
  s[0] == "L" ? [76] :
  s[0] == "M" ? [77] :
  s[0] == "N" ? [78] :
  s[0] == "O" ? [79] :
  s[0] == "P" ? [80] :
  s[0] == "Q" ? [81] :
  s[0] == "R" ? [82] :
  s[0] == "S" ? [83] :
  s[0] == "T" ? [84] :
  s[0] == "U" ? [85] :
  s[0] == "V" ? [86] :
  s[0] == "W" ? [87] :
  s[0] == "X" ? [88] :
  s[0] == "Y" ? [89] :
  s[0] == "Z" ? [90] :
  s[0] == "[" ? [91] :
  s[0] == "\\" ? [92] :
  s[0] == "]" ? [93] :
  s[0] == "^" ? [94] :
  s[0] == "_" ? [95] :
  s[0] == "`" ? [96] :
  s[0] == "a" ? [97] :
  s[0] == "b" ? [98] :
  s[0] == "c" ? [99] :
  s[0] == "d" ? [100] :
  s[0] == "e" ? [101] :
  s[0] == "f" ? [102] :
  s[0] == "g" ? [103] :
  s[0] == "h" ? [104] :
  s[0] == "i" ? [105] :
  s[0] == "j" ? [106] :
  s[0] == "k" ? [107] :
  s[0] == "l" ? [108] :
  s[0] == "m" ? [109] :
  s[0] == "n" ? [110] :
  s[0] == "o" ? [111] :
  s[0] == "p" ? [112] :
  s[0] == "q" ? [113] :
  s[0] == "r" ? [114] :
  s[0] == "s" ? [115] :
  s[0] == "t" ? [116] :
  s[0] == "u" ? [117] :
  s[0] == "v" ? [118] :
  s[0] == "w" ? [119] :
  s[0] == "x" ? [120] :
  s[0] == "y" ? [121] :
  s[0] == "z" ? [122] :
  s[0] == "{" ? [123] :
  s[0] == "|" ? [124] :
  s[0] == "}" ? [125] :
  s[0] == "~" ? [126] :
  s[0] == "\u007F" ? [127] :
  undef;

// self-test
function strord_assert(actual, expected, msg) =
  actual == expected ? "ok" :
  str("FAILED: ", msg, " (EXPECTED:", expected, " ACTUAL:", actual, ")");

echo(strord_assert(let (all=chr([1:1:127])) all == chr(ord(all)), true, "ord 1"));
echo(strord_assert(ord(""), [], "ord 2"));
echo(strord_assert(ord("A"), [65], "ord 3"));
